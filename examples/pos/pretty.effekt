module examples/pretty

import data/option
import data/list
import data/string

// A very naive (backtracking) pretty printer
// ===========================

// Contextual parameters
effect Indentation(): Int
effect Horizontal(): Boolean

// Document emitters
effect Text(t: String): Unit
effect Line(indent: Int): Unit

// Backtracking search for layouts
effect LayoutChoice(): Boolean
effect LayoutFail[A](): A

// TODO turn this into an effect later to make configurable
def defaultIndent() = 2

def layout[R] { p : R / { LayoutChoice, LayoutFail } }: Option[R] =
  try { Some(p()) } with {
    case LayoutFail() => None()
    case LayoutChoice() => resume(true) match {
      case None() => resume(false)
      case Some(r) => Some(r)
    }
  }

def printer(width: Int) { p: Unit / { Text, Line, Indentation, Horizontal } } = {
  var pos: Int = 0;
  var out = "";
  try { p(); out } with {
    case Text(t) => {
      pos = pos + t.length;
      if (pos > width) {
        do LayoutFail()
      } else {
        out = out ++ t;
        resume(())
      }
    }
    case Line(indent) => {
      pos = indent;
      out = out ++ "\n" ++ (" ".repeat(indent));
      resume(())
    }
    case Horizontal() => resume(do LayoutChoice())
    case Indentation() => resume(0)
  }
}

// TODO moving pretty to the top moves printer out of scope, why?
// TODO using the wrong kind of argument section (like `opt.getOrElse("")`) crashes the compiler.
def pretty(width: Int) { p: Unit / { Text, Line, Indentation, LayoutChoice, LayoutFail, Horizontal } } =
  (layout { printer(width) { p() } }).getOrElse { "Cannot print document, since it would overflow." }

def horizontal { p: Unit / { Horizontal } } = try { p () } with {
  case Horizontal() => resume(true)
}

def vertical { p: Unit / { Horizontal } } = try { p () } with {
  case Horizontal() => resume(false)
}

def group { p: Unit / { Horizontal, Text, Line } } =
  if (do LayoutChoice())
    horizontal { p() }
  else
    vertical { p() }

def text(s: String) = do Text(s)

def lineOr(replace: String) =
  if (do Horizontal())
    do Text(replace)
  else
    do Line(do Indentation())

def line() =
  lineOr(" ")

def softline() =
  group { line() }

def linebreak() =
  lineOr("")

def softbreak() =
  group { linebreak() }


// a non-breakable space
def space() =
  text(" ")

def spaces(n: Int) =
  if (n > 0) text(" ".repeat(n)) else ()

def nest[R](j: Int) { p: R / Indentation }: R / Indentation = try { p () } with {
  case Indentation() => resume(do Indentation() + j)
}

// uses the default indentation to nest a document
def nested[R] { p: R / Indentation }: R / Indentation =
  nest(defaultIndent()) { p() }

def nesting[R] { p: Int => R / Indentation }: R / Indentation =
  p(do Indentation())

def parens { p: Unit }: Unit / Text = {
  text("("); p(); text(")")
}

def braces { p: Unit }: Unit / Text = {
  text("{"); p(); text("}")
}


def main() = {

  def example1(l: List[Int]) = {
    text("[");
    l.foreach { n =>
      text(show(n));
      text(",");
      line()
    };
    text("]")
  }

  println("----------");
  println(pretty(10) { example1([1,2,3,4,5,6,7,8,9,1,2,3,4]) });

  def example2() = {
    text("def"); space(); text("foo"); parens {
      group {
        nest(2) {
          linebreak();
          group { text("x"); text(":"); space(); text("Int"); text(",") };
          line();
          group { text("y"); text(":"); space(); text("String") }
        };
        linebreak()
      }
    }
  }
  def example3() = {
    example2();
    space();
    braces {
      group {
        nest(2) {
          line();
          text("var"); space(); text("z"); space(); text("="); space(); text("42"); text(";")
        };
        line()
      }
    }
  }

  println("----------");
  println(pretty(30) { example2() });
  println(pretty(20) { example2() });

  println("----------");
  println(pretty(50) { example3() });
  println(pretty(15) { example3() })
}