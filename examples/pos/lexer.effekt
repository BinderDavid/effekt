module examples/pos/lexer

import text/string
import text/regex
import immutable/option

// TODO Here the LSP plugin currently fails
import examples/pos/pretty

// =======================
// Common
// =======================

record Position(line: Int, col: Int, index: Int)

type Token {
    Number(content: String, pos: Position);
    Ident(content: String, pos: Position);
    Punct(content: String, pos: Position)
}
def content(t: Token): String = t match {
    case Number(content, _) => content
    case Ident(content, _) => content
    case Punct(content, _) => content
}

def position(t: Token): Position = t match {
    case Number(_, position) => position
    case Ident(_, position) => position
    case Punct(_, position) => position
}

// =======================
// Lexing
// =======================

effect EOS[A](): A
effect LexerError[A](msg: String, pos: Position): A

effect Lexer {
  def peek(): Option[Token]
  def next(): Token
}

def lexer[R](in: String) { prog: R / Lexer } : R / LexerError = {

    val numberRx = regex("^[0-9]+");
    val identRx  = regex("^[a-zA-Z]+");
    val punctRx  = regex("^[=,.()\\[\\]{}:]");
    val spaceRx  = regex("^[ \t]+");
    val lineRx  = regex("^[\n]");

    var index = 0;
    var col = 1;
    var line = 1;

    def position() = Position(line, col, index)
    def input() = in.substring(index)

    def consume(len: Int): Unit = {
        col = col + len;
        index = index + len
    }

    def eos(): Boolean = index >= in.length

    def skipWhitespaces(): Unit =  {
        spaceRx.exec(input()).map { m =>
            consume(m.matched.length)
        }.orElse {
            lineRx.exec(input()).map { m =>
                consume(m.matched.length);
                line = line + 1;
                col = 1
            }
        }.map { m => skipWhitespaces() };
        ()
    }

    def tryMatch(regex: Regex) { f: String => Token } : Option[(Token, Int)] =
        regex.exec(input()).map { m =>
          (f(m.matched), m.matched.length)
        }

    def number() = tryMatch(numberRx) { m => Number(m, position()) }
    def ident()  = tryMatch(identRx) { m => Ident(m, position()) }
    def punct()  = tryMatch(punctRx) { m => Punct(m, position()) }

    def lexeme() = number().orElse { ident() }.orElse { punct() }

    // skip initial whitespace
    skipWhitespaces();

    try { prog() } with Lexer {
        def peek() =
            if (eos())
                resume(None())
            else
                resume(lexeme().map { m => m.first })
        def next() =
            if (eos())  {
                do LexerError("Unexpected EOS", position())
            } else {
                val result = lexeme()
                    .map { m =>
                        consume(m.second);
                        skipWhitespaces();
                        m.first
                    }
                    .getOrElse {
                        do LexerError("Cannot tokenize input", position())
                    };

                resume(result)
            }
    }
}

// =======================
// Parsing
// =======================
effect Nondet {
  def alt(): Boolean
  def fail[A](msg: String): A
}

effect Parser = { Nondet, Lexer }

type ParseResult[R] {
  Success(t: R);
  Failure(msg: String)
}


// Simplified signatures
//   def lexer[R](in: String) { prog: R / Lexer } : R / LexerError
//   def parse[R](input: String) { p: R / { Nondet, Lexer } }: ParseResult[R] / {}
//
// In Koka this would have a type like
//   def lexer[R, E](in: String) { prog: R / { Lexer, E } } : R / { LexerError, E }
//   def parse[R, E](input: String) { p: R / { Nondet, Lexer, E } }: ParseResult[R] / E
def parse[R](input: String) { p: R / {Parser} }: ParseResult[R] = try {
    lexer(input) { Success(p()) }
  } with Nondet {
    def alt() = resume(true) match {
      case Failure(msg) => resume(false)
      case Success(res) => Success(res)
    }
    def fail(msg) = Failure(msg)
  } with LexerError { (msg, pos) =>
    Failure(msg)
  }


// =======================
// Parser Combinators
// =======================

def accept { p: Token => Boolean } : Token / { Nondet, Lexer } = {
    val got = do next();
    if (p(got)) {
        got
    } else {
        do fail("Unexpected token " ++ show(got))
    }
}
def ident() = accept { t => t match {
    case Ident(content, pos) => true
    case Number(content, pos) => false
    case Punct(content, pos) => false
}}
def number() = accept { t => t match {
    case Ident(content, pos) => false
    case Number(content, pos) => true
    case Punct(content, pos) => false
}}
def punct(p: String) = accept { t => t match {
    case Ident(content, pos) => false
    case Number(content, pos) => false
    case Punct(content, pos) => content == p
}}

def or[R] { p: R } { q: R } =
  if (alt()) { p() } else { q() }

def opt[R] { p: R }: Option[R] / Parser =
   or { Some(p()) } { None() }

def many { p: Unit }: Unit / Parser =
    or { some { p() } } { () }

def some { p: Unit }: Unit / Parser =
    { p(); many { p() } }

def kw(exp: String): Unit / Parser = {
    val got = id();
    if (got == exp) () else fail("Expected keyword " ++ exp ++ " but got " ++ got)
}

def id(): String / Parser = ident().content


// =======================
// Examples
// =======================
type Tree {
    NumLit(value: Int);
    Var(name: String);
    Let(name: String, binding: Tree, body: Tree);
    App(name: String, arg: Tree)
}

// A language that distiguishes between effectful statements and pure expressions
type Expr {
    CLit(value: Int);
    CVar(name: String)
}
type Stmt {
    CLet(name: String, binding: Stmt, body: Stmt);
    CApp(name: String, arg: Expr);
    CRet(expr: Expr)
}

// =======================
// ANF
// =======================

effect Bind(e: Stmt): Expr
effect Fresh(): Int

def freshVars[R] { prog: R / Fresh } : R = {
    var i = 0;
    try { prog() } with Fresh { () =>
        i = i + 1;
        resume(i)
    }
}

def bindHere { prog: Stmt / Bind } : Stmt / Fresh =
    try { prog() } with Bind { (e) =>
        val id = "x" ++ show(do Fresh());
        CLet(id, e, resume(CVar(id)))
    }

def traverse(e: Tree): Stmt / { Bind, Fresh } = e match {
    case NumLit(n) => CRet(CLit(n))
    case Var(n) => CRet(CVar(n))
    case App(name, arg) => CApp(name, do Bind(traverse(arg)))
    case Let(x, b, body) => CLet(x, bindHere { traverse(b) }, bindHere { traverse(body) })
}

def translate(e: Tree): Stmt =
    freshVars { bindHere { traverse(e) } }


def parseNum(): Tree / Parser =
    number().content.toInt.map { v =>
        NumLit(v)
    }.getOrElse {
        fail("cannot convert input to integer")
    }

def parseVar(): Tree / Parser =
    Var(id())

def parseLit() = or { parseVar() } { parseNum() }

def parseLet(): Tree / Parser = {
    kw("let");
    val name = id();
    punct("=");
    val binding = parseExpr();
    kw("in");
    val body = parseExpr();
    Let(name, binding, body)
}

def parseAtomic() = or { parseLit() } {
    punct("(");
    val res = parseExpr();
    punct(")");
    res
}

def parseApp(): Tree / Parser = {
    val funName = id();
    punct("(");
    val arg = parseExpr();
    punct(")");
    App(funName, arg)
}

def parseExpr(): Tree / Parser =
    or { parseLet() } { or { parseApp() } { parseAtomic() } }

// Pretty printer for the example tree

// TODO also export type aliases from a module
effect Pretty = { Text, Line, Indentation, Layout, Horizontal }

def toDoc(t: Tree): Unit / Pretty = t match {
    case NumLit(value) => text(show(value))
    case Var(name) => text(name)
    case Let(name, binding, body) =>
        text("let"); space(); text(name); space(); text("=");
        group {
            nested { line(); toDoc(binding) };
            line();
            text("in")
        };
        group { nested { line(); toDoc(body) } }

    case App(name, arg) =>
        text(name); parens {
            group { nested {
                linebreak();
                toDoc(arg)
            }; linebreak() }
        }
}

def toDocExpr(t: Expr): Unit / Pretty = t match {
    case CLit(value) => text(show(value))
    case CVar(name) => text(name)
}

def toDocStmt(s: Stmt): Unit / Pretty = s match {
    case CLet(name, binding, body) =>
        text("let"); space(); text(name); space(); text("=");
        group {
            nested { line(); toDocStmt(binding) };
            line();
            text("in")
        };
        group { nested { line(); toDocStmt(body) } }

    case CApp(name, arg) =>
        text(name); parens {
            group { nested {
                linebreak();
                toDocExpr(arg)
            }; linebreak() }
        }

    case CRet(expr) =>
        text("return"); space(); toDocExpr(expr)

}

// Example grammar
// <EXPR> ::= <NUMBER> | <IDENT> `(` <EXPR> (`,` <EXPR>)*  `)`
// we count the number of nodes as semantic action
def parseSampleExpr(): Int / Parser =
    or { number(); 1 } {
        var count = 1;
        ident();
        punct("(");
        count = count + parseSampleExpr();
        many {
            punct(",");
            count = count + parseSampleExpr()
        };
        punct(")");
        count
    }

def main() = {
    // simple string ops
    val r = regex("^[0-9]+");
    println("abcdefg".charAt(3));
    println("abcdefg".charAt(10));
    println("abcdefg".length);
    println(r.exec("0bcd0").map { m => m.index });

    // lexer
    try {
        lexer("abcd 12345,4\n(efgh)bar(baz)") {
            while (peek().isDefined) {
                println(next())
            }
        }
    } with LexerError { (msg, pos) => pos match {
        case Position(line, col, idx) =>
            println(show(line) ++ ":" ++ show(col) ++ " " ++ msg)
        }
    };

    // parser
    println(parse("42") { parseSampleExpr() });
    println(parse("foo(1)") { parseSampleExpr() });
    println(parse("foo(1, 2)") { parseSampleExpr() });
    println(parse("foo(1, 2, 3, 4)") { parseSampleExpr() });
    println(parse("foo(1, 2, bar(4, 5))") { parseSampleExpr() });
    println(parse("foo(1, 2,\nbar(4, 5))") { parseSampleExpr() });


    val exampleProg = "let x = (let y = f(let z = 1 in z) in 1) in 42";

    println(parse("42") { parseExpr() });
    println(parse("let x = 4 in 42") { parseExpr() });
    println(parse("let x = let y = 2 in 1 in 42") { parseExpr() });
    println(parse("let x = (let y = 2 in 1) in 42") { parseExpr() });
    println(parse("let x = (let y = f(42) in 1) in 42") { parseExpr() });
    println(parse(exampleProg) { parseExpr() });

    parse(exampleProg) { parseExpr() } match {
        case Success(tree) =>
            println("\nSource Program:\n" ++ pretty(30) { toDoc(tree) });
            val target = translate(tree);
            println("\nTarget Program:\n" ++ pretty(30) { toDocStmt(target) })

        case Failure(msg) => println(msg)
    }
}