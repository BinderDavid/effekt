interface Coroutine[A] {
    def cyield(a: A): Unit
}

def fib(n: Int): Unit / Coroutine[Int] = {
    var m = n;
    var n1 = 0;
    var n2 = 1;
    while (m != 0) {
        do cyield(n1 + n2);
        val t1 = n1
        n1 = n2
        n2 = t1 + n2
        m = m - 1
    }
}

def handleCoroutine[B] { f: () => Unit / Coroutine[B] }: Unit = {
    try {
        f()
    } with Coroutine[B] {
        def cyield(a) = {
            println(a)
            resume(())
        }
    }
}

def main() = {
    handleCoroutine[Int] {
        fib(100)
    }
}