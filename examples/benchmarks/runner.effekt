import args
import bench

def benchmark(iterations: Int) { bench: Int => Int } { test: => Unit }: Unit = commandLineArgs() match {
  // test mode
  case Nil() => test()

  // bench mode
  case Cons(problemSize, _) =>
    with on[WrongFormat].panic;

    val n = problemSize.toInt

    iterations.repeat {
      val before = relativeTimestamp()
      ignore(bench(n))
      val after = relativeTimestamp()
      val nanos = after - before
      println(nanos)
    }
}

/**
 * The inliner might remove unused computation (if pure), which is not desired
 * for benchmarking. Since externs are opaque to the optimizer, just wrap the
 * result of the computation to benchmark in `ignore`.
 */
extern io def ignore[T](value: T): Unit =
  js "$effekt.unit"
  llvm "ret %Pos zeroinitializer"

def main() = ()