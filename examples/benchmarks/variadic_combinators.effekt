import immutable/list

def vfix(lst: List[List[=> (Int => Int at {}) at {}] => (Int => Int at {}) at {}]): List[=> (Int => Int at {}) at {}] = {
    lst.map { el => box { () => el(vfix(lst)) } }
}

// TODO: first/second/third could be replaced with standard library functions
//       (once they are commonly available in all backends)

def first(lst: List[=> (Int => Int at {}) at {}]) = lst match {
    case Cons(a, _) => a
    case _ => box { () => box { (x: Int) => x } }
}

def second(lst: List[=> (Int => Int at {}) at {}]) = lst match {
    case Cons(_, Cons(b, _)) => b
    case _ => box { () => box { (x: Int) => x } }
}

def third(lst: List[=> (Int => Int at {}) at {}]) = lst match {
    case Cons(_, Cons(_, Cons(c, _))) => c
    case _ => box { () => box { (x: Int) => x } }
}

def f1(fs: List[=> (Int => Int at {}) at {}]) =
    box { (n: Int) =>
        if (n == 0) 0
        else second(fs)()(n - 1)
    }

def f2(fs: List[=> (Int => Int at {}) at {}]) =
    box { (n: Int) =>
        if (n == 0) 1
        else third(fs)()(n - 1)
    }

def f3(fs: List[=> (Int => Int at {}) at {}]) =
    box { (n: Int) =>
        if (n == 0) 2
        else first(fs)()(n - 1)
    }

def mod3(x: Int): Int = first(vfix([f1,f2,f3]))()(x)

def main() = {
    println(mod3(999))
    println(mod3(1000))
    println(mod3(1001))
}
