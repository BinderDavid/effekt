module immutable/seq

/**
 * This file implements the [[Seq]] type as a general purpose functional sequence.
 *
 * Implemented as a 2-3 finger tree, it supports
 * - prepend and append in amortized O(1),
 * - concat(m, n) in O(log(min(m, n)))
 * - first and last in amortized O(1)
 * - size in amortized O(1)
 *
 * More information on finger trees:
 *   https://www.staff.city.ac.uk/~ross/papers/FingerTree.pdf
 */


/**
 * Exception[NoSuchElement] is raised when accessing non-existing elements
 * or splitting empty collections.
 */
record NoSuchElement()

/**
 * Internal grouping of 1-4 elements
 *
 * It is called digit since Okasaki (1998) calls finger trees "numerical operations".
 */
type Digit[A] {
  One(value: A)
  Two(first: A, second: A)
  Three(first: A, second: A, third: A)
  Four(first: A, second: A, third: A, fourth: A)
}

type Node[A] {
  // These are necessary to avoid polymorphic recursion
  Leaf2(first: A, second: A)
  Leaf3(first: A, second: A, third: A)
  Node2(size: Int, first: Node[A], second: Node[A])
  Node3(size: Int, first: Node[A], second: Node[A], third: Node[A])
}

/**
 * Internal duplicate of Seq
 *
 * splitting into two type parameters is necessary since our MLton backend does
 * not support mutually recursive data type declarations.
 */
type Finger[A, N] {
  NoFinger()
  SingleFinger(value: Node[A])
  DeepFinger(size: Int, prefix: N, middle: Finger[A, N], suffix: N)
}

/**
 * Internal
 */
type Tree[A] = Finger[A, Digit[Node[A]]]

type TreeView[A] {
  TreeIsEmpty()
  TreeView(el: Node[A], rest: Tree[A])
}


/**
 * Sequences are represented as 2-3 finger trees.
 */
type Seq[A] {
  Empty()
  Single(value: A)
  Deep(size: Int, prefix: Digit[A], middle: Tree[A], suffix: Digit[A])
}

/**
 * Result of splitting a sequence at the front or back.
 */
type View[A] {
  IsEmpty()
  View(element: A, remainder: Seq[A])
}

def toTree[A](d: Digit[Node[A]]): Tree[A] =  d match {
  case One(a) => SingleFinger(a)
  case Two(a, b) => DeepFinger(2, One(a), NoFinger(), One(b))
  case Three(a, b, c) => DeepFinger(3, Two(a, b), NoFinger(), One(c))
  case Four(a, b, c, d) => DeepFinger(4, Three(a, b, c), NoFinger(), One(d))
}

def toSeq[A](d: Digit[A]): Seq[A] =  d match {
  case One(a) => Single(a)
  case Two(a, b) => Deep(2, One(a), NoFinger(), One(b))
  case Three(a, b, c) => Deep(3, Two(a, b), NoFinger(), One(c))
  case Four(a, b, c, d) => Deep(4, Three(a, b, c), NoFinger(), One(d))
}

def toDigitNode[A](n: Node[A]): Digit[Node[A]] = n match {
  case Node2(_, a, b) => Two(a, b)
  case Node3(_, a, b, c) => Three(a, b, c)
  case _ => <{ "Should not happen" }>
}

def toDigit[A](n: Node[A]): Digit[A] = n match {
  case Leaf2(a, b) => Two(a, b)
  case Leaf3(a, b, c) => Three(a, b, c)
  case _ => <{ "Should not happen" }>
}

// Measure
// -------

def size[A](node: Digit[A]): Int = node match {
  case One(_) => 1
  case Two(_, _) => 2
  case Three(_, _, _) => 3
  case Four(_, _, _, _) => 4
}

def size[A](node: Node[A]): Int = node match {
  case Leaf2(_, _) => 2
  case Leaf3(_, _, _) => 3
  case Node2(s, _, _) => s
  case Node3(s, _, _, _) => s
}

def sizeDeep[A](node: Digit[Node[A]]): Int = node match {
  case One(a) => a.size
  case Two(a, b) => a.size + b.size
  case Three(a, b, c) => a.size + b.size + c.size
  case Four(a, b, c, d) => a.size + b.size + c.size + d.size
}

def size[A](tree: Tree[A]): Int = tree match {
  case NoFinger() => 0
  case SingleFinger(value) => value.size
  case DeepFinger(size, _, _, _) => size
}

/**
 * The size of the given sequence
 */
def size[A](seq: Seq[A]): Int = seq match {
  case Empty() => 0
  case Single(value) => 1
  case Deep(size, _, _, _) => size
}


// smart constructors
def deepFinger[A](prefix: Digit[Node[A]], middle: Tree[A], suffix: Digit[Node[A]]): Tree[A] =
  DeepFinger(prefix.sizeDeep + middle.size + suffix.sizeDeep, prefix, middle, suffix)

def deep[A](prefix: Digit[A], middle: Tree[A], suffix: Digit[A]): Seq[A] =
  Deep(prefix.size + middle.size + suffix.size, prefix, middle, suffix)

def node2[A](first: Node[A], second: Node[A]): Node[A] =
  Node2(first.size + second.size, first, second)

def node3[A](first: Node[A], second: Node[A], third: Node[A]): Node[A] =
  Node3(first.size + second.size + third.size, first, second, third)

def consFinger[A](head: Node[A], tail: Tree[A]): Tree[A] = tail match {
  case NoFinger()                     => SingleFinger(head)
  case SingleFinger(b)                => deepFinger(One(head), NoFinger(), One(b))
  case DeepFinger(_, One(b), m, rest)    => deepFinger(Two(head, b), m, rest)
  case DeepFinger(_, Two(b, c), m, rest) => deepFinger(Three(head, b, c), m, rest)
  case DeepFinger(_, Three(b, c, d), m, rest) => deepFinger(Four(head, b, c, d), m, rest)
  case DeepFinger(_, Four(b, c, d, e), m, rest) =>
    deepFinger(Two(head, b), consFinger(node3(c, d, e), m), rest)
}

def consFingerRight[A](init: Tree[A], tail: Node[A]): Tree[A] = init match {
  case NoFinger()                      => SingleFinger(tail)
  case SingleFinger(b)                 => deepFinger(One(b), NoFinger(), One(tail))
  case DeepFinger(_, rest, m, One(b))    => deepFinger(rest, m, Two(b, tail))
  case DeepFinger(_, rest, m, Two(b, c)) => deepFinger(rest, m, Three(b, c, tail))
  case DeepFinger(_, rest, m, Three(b, c, d)) => deepFinger(rest, m, Four(b, c, d, tail))
  case DeepFinger(_, rest, m, Four(b, c, d, e)) =>
    deepFinger(rest, consFingerRight(m, node3(b, c, d)), Two(e, tail))
}

def cons[A](head: A, tail: Seq[A]): Seq[A] = tail match {
  case Empty()                          => Single(head)
  case Single(b)                        => Deep(2, One(head), NoFinger(), One(b))
  case Deep(s, One(b), m, rest)         => Deep(s + 1, Two(head, b), m, rest)
  case Deep(s, Two(b, c), m, rest)      => Deep(s + 1, Three(head, b, c), m, rest)
  case Deep(s, Three(b, c, d), m, rest) => Deep(s + 1, Four(head, b, c, d), m, rest)
  case Deep(s, Four(b, c, d, e), m, rest) =>
    Deep(s + 1, Two(head, b), consFinger(Leaf3(c, d, e), m), rest)
}

def consRight[A](init: Seq[A], tail: A): Seq[A] = init match {
  case Empty()                          => Single(tail)
  case Single(b)                        => Deep(2, One(b), NoFinger(), One(tail))
  case Deep(s, rest, m, One(b))         => Deep(s + 1, rest, m, Two(b, tail))
  case Deep(s, rest, m, Two(b, c))      => Deep(s + 1, rest, m, Three(b, c, tail))
  case Deep(s, rest, m, Three(b, c, d)) => Deep(s + 1, rest, m, Four(b, c, d, tail))
  case Deep(s, rest, m, Four(b, c, d, e)) =>
    Deep(s + 1, rest, consFingerRight(m, Leaf3(b, c, d)), Two(e, tail))
}

def unconsFinger[A](seq: Tree[A]): TreeView[A] = seq match {
  case NoFinger()   => TreeIsEmpty()
  case SingleFinger(x) => TreeView(x, NoFinger())
  // TODO this is a tail-call-modulo-context
  case DeepFinger(s, One(a), m, rest) => TreeView(a, unconsFinger(m) match {
    case TreeIsEmpty() => rest.toTree
    case TreeView(b, m2) => DeepFinger(s - a.size, b.toDigitNode, m2, rest)
  })
  case DeepFinger(s, Two(a, b), m, rest) => TreeView(a, DeepFinger(s - a.size, One(b), m, rest))
  case DeepFinger(s, Three(a, b, c), m, rest) => TreeView(a, DeepFinger(s - a.size, Two(b, c), m, rest))
  case DeepFinger(s, Four(a, b, c, d), m, rest) => TreeView(a, DeepFinger(s - a.size, Three(b, c, d), m, rest))
}

// this could be called "uncons", "first", "front", "head", "popFront", "start", "popStart"
def uncons[A](seq: Seq[A]): View[A] = seq match {
  case Empty()   => IsEmpty()
  case Single(x) => View(x, Empty())
  case Deep(s, One(a), m, rest) => View(a, unconsFinger(m) match {
    case TreeIsEmpty() => rest.toSeq
    case TreeView(b, m2) => Deep(s - 1, b.toDigit, m2, rest)
  })
  case Deep(s, Two(a, b), m, rest) => View(a, Deep(s - 1, One(b), m, rest))
  case Deep(s, Three(a, b, c), m, rest) => View(a, Deep(s - 1, Two(b, c), m, rest))
  case Deep(s, Four(a, b, c, d), m, rest) => View(a, Deep(s - 1, Three(b, c, d), m, rest))
}

def unconsRightFinger[A](seq: Tree[A]): TreeView[A] = seq match {
  case NoFinger()   => TreeIsEmpty()
  case SingleFinger(x) => TreeView(x, NoFinger())
  // TODO this is a tail-call-modulo-context
  case DeepFinger(s, init, m, One(a)) => TreeView(a, unconsRightFinger(m) match {
    case TreeIsEmpty() => init.toTree
    case TreeView(b, m2) => DeepFinger(s - a.size, init, m2, b.toDigitNode)
  })
  case DeepFinger(s, init, m, Two(b, a)) => TreeView(a, DeepFinger(s - a.size, init, m, One(b)))
  case DeepFinger(s, init, m, Three(c, b, a)) => TreeView(a, DeepFinger(s - a.size, init, m, Two(c, b)))
  case DeepFinger(s, init, m, Four(d, c, b, a)) => TreeView(a, DeepFinger(s - a.size, init, m, Three(d, c, b)))
}

// this could be called "uncons", "first", "front", "head", "popFront", "start", "popStart"
def unconsRight[A](seq: Seq[A]): View[A] = seq match {
  case Empty()   => IsEmpty()
  case Single(x) => View(x, Empty())
  case Deep(s, init, m, One(a)) => View(a, unconsFinger(m) match {
    case TreeIsEmpty() => init.toSeq
    case TreeView(b, m2) => Deep(s - 1, init, m2, b.toDigit)
  })
  case Deep(s, init, m, Two(a, b)) => View(a, Deep(s - 1, init, m, One(b)))
  case Deep(s, init, m, Three(a, b, c)) => View(a, Deep(s - 1, init, m, Two(b, c)))
  case Deep(s, init, m, Four(a, b, c, d)) => View(a, Deep(s - 1, init, m, Three(b, c, d)))
}

def concatTree[A](first: Tree[A], middle: List[Node[A]], second: Tree[A]): Tree[A] = {

  // can we get rid of the list?

  def prepend(digit: List[Node[A]], l: Tree[A]): Tree[A] = digit match {
    case Nil() => l
    case Cons(head, tail) => consFinger(head, prepend(tail, l))
  }

  def append(l: Tree[A], digit: List[Node[A]]): Tree[A] = digit match {
    case Nil() => l
    case Cons(head, tail) => append(consFingerRight(l, head), tail)
  }

  def consFinger(digit: Digit[Node[A]], l: Tree[A]): Tree[A] = digit match {
    case One(a) => consFinger(a, l)
    case Two(a, b) => consFinger(a, consFinger(b, l))
    case Three(a, b, c) => consFinger(a, consFinger(b, consFinger(c, l)))
    case Four(a, b, c, d) => consFinger(a, consFinger(b, consFinger(c, consFinger(d, l))))
  }

  def toList(digit: Digit[Node[A]]): List[Node[A]] = digit match {
    case One(a) => Cons(a, Nil())
    case Two(a, b) => Cons(a, Cons(b, Nil()))
    case Three(a, b, c) => Cons(a, Cons(b, Cons(c, Nil())))
    case Four(a, b, c, d) => Cons(a, Cons(b, Cons(c, Cons(d, Nil()))))
  }

  // rebalance
  def nodes(t: List[Node[A]]): List[Node[A]] = t match {
    case Cons(a, Cons(b, Nil())) => Cons(node2(a, b), Nil())
    case Cons(a, Cons(b, Cons(c, Nil()))) => Cons(node3(a, b, c), Nil())
    case Cons(a, Cons(b, Cons(c, Cons(d, Nil())))) => Cons(node2(a, b), Cons(node2(c, d), Nil()))
    case Cons(a, Cons(b, Cons(c, rest))) => Cons(node3(a, b, c), nodes(rest))
    case _ => <>
  }

  def go(prefix: Tree[A], middle: List[Node[A]], suffix: Tree[A]): Tree[A] =
    (prefix, suffix) match {
      case (NoFinger(), ys) => prepend(middle, ys)
      case (xs, NoFinger()) => append(xs, middle)
      case (SingleFinger(x), ys) => consFinger(x, prepend(middle, ys))
      case (xs, SingleFinger(y)) => consFingerRight(append(xs, middle), y)
      case (DeepFinger(size1, p1, m1, s1), DeepFinger(size2, p2, m2, s2)) =>
        val list = s1.toList.append(middle).append(p2.toList)
        DeepFinger(size1 + size2, p1, go(m1, nodes(list), m2), s2)
    }

  go(first, middle, second)
}

def concat[A](first: Seq[A], second: Seq[A]): Seq[A] = {
  def nodes(t: List[A]): List[Node[A]] = t match {
    case Cons(a, Cons(b, Nil())) => Cons(Leaf2(a, b), Nil())
    case Cons(a, Cons(b, Cons(c, Nil()))) => Cons(Leaf3(a, b, c), Nil())
    case Cons(a, Cons(b, Cons(c, Cons(d, Nil())))) => Cons(Leaf2(a, b), Cons(Leaf2(c, d), Nil()))
    case Cons(a, Cons(b, Cons(c, rest))) => Cons(Leaf3(a, b, c), nodes(rest))
    case _ => <>
  }
  def toList(digit: Digit[A]): List[A] = digit match {
    case One(a) => Cons(a, Nil())
    case Two(a, b) => Cons(a, Cons(b, Nil()))
    case Three(a, b, c) => Cons(a, Cons(b, Cons(c, Nil())))
    case Four(a, b, c, d) => Cons(a, Cons(b, Cons(c, Cons(d, Nil()))))
  }

  (first, second) match {
    case (Empty(), other) => other
    case (other, Empty()) => other
    case (Single(a), other) => cons(a, other)
    case (other, Single(a)) => consRight(other, a)
    case (Deep(size1, p1, m1, s1), Deep(size2, p2, m2, s2)) =>
      Deep(size1 + size2, p1, concatTree(m1, nodes(s1.toList.append(p2.toList)), m2), s2)
  }
}


def isEmpty[A](s: Seq[A]): Boolean = s match {
  case Empty() => true
  case _ => false
}

def nonEmpty[A](s: Seq[A]): Boolean = s match {
  case Empty() => false
  case _ => true
}

def head[A](s: Seq[A]): A / Exception[NoSuchElement] = s.uncons match {
  case IsEmpty() => do raise(NoSuchElement(), "Calling `head` on empty sequence.") match {}
  case View(element, _) => element
}

def tail[A](s: Seq[A]): Seq[A] / Exception[NoSuchElement] = s.uncons match {
  case IsEmpty() => do raise(NoSuchElement(), "Calling `tail` on empty sequence.") match {}
  case View(element, rest) => rest
}
