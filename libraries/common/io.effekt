module io

import ref
import queue

extern include llvm "../llvm/io.ll"
extern include js "../js/io.js"


// Event Loop
// ----------

interface Eventloop {}

type Task[T] = () => T / Eventloop at {io, control, global}

def eventloop(program: Task[Unit]): Unit = direct::eventloop(box {
  try program() with Eventloop {}
})

def spawn(task: Task[Unit]): Unit / Eventloop =
  direct::spawn(box{ try task() with Eventloop {} })

def yield(): Unit / Eventloop =
  direct::yield()

def abort(): Nothing / Eventloop =
  direct::abort()

namespace direct {

  extern io def eventloop(program: () => Unit at {global,io,control}): Unit =
  js "${program}().run()"
  llvm """
    call void @run(%Neg %program)
    %loop = call ptr @uv_default_loop()
    call i32 @uv_run(ptr %loop, i32 0)
    call void @uv_loop_close(ptr %loop)
    ret %Pos zeroinitializer
  """

  extern control def spawn(task: () => Unit at {global,io,control}): Unit =
    js "$effekt.callcc(callback => { setTimeout(() => callback($effekt.unit), 0); ${task}().run()})"
    llvm """
      call void @c_timer_start(%Int 0, %Stack %stack)
      call void @run(%Neg %task)
      ret void
    """

  extern control def yield(): Unit =
    js "$effekt.callcc(callback => setTimeout(() => callback($effekt.unit), 0))"
    llvm """
      call void @c_timer_start(%Int 0, %Stack %stack)
      ret void
    """

  extern control def abort(): Nothing =
    js "$effekt.callcc(callback => { return })"
    llvm """
      call void @eraseStack(%Stack %stack)
      ret void
    """

}

// Promises
// --------

extern type Promise[T]
  // = js "{resolve: Æ’, promise: Promise}"
  // = llvm "{tag: 0, obj: Promise*}"

interface Promises {
  def promise[T](p: Task[T]): Promise[T]
  def await[T](p: Promise[T]): T
}

namespace promise {
  extern js """
    function promise$make() {
      let resolve;
      const promise = new Promise((res, rej) => {
        resolve = res;
      });
      return { resolve: resolve, promise: promise };
    }
  """

  extern io def make[T](): Promise[T] =
    js "promise$make()"
    llvm """
      %promise = call %Pos @c_promise_make()
      ret %Pos %promise
    """

  extern control def resolve[T](promise: Promise[T], value: T): Unit =
    js "$effekt.callcc(callback => { ${promise}.resolve(${value}); callback($effekt.unit)})"
    llvm """
      call void @c_promise_resolve(%Pos %promise, %Pos %value, %Stack %stack)
      ret void
    """

  extern control def await[T](promise: Promise[T]): T =
    js "$effekt.callcc(callback => ${promise}.promise.then(res => callback(res)))"
    llvm """
      call void @c_promise_await(%Pos %promise, %Stack %stack)
      ret void
    """
}


