module bytes

/**
 * A memory managed, mutable, fixed-length buffer of bytes
 */
extern type Bytes
  // = llvm "%Pos"
  // = js "Uint8Array"


extern io def empty(capacity: Int): Bytes =
  js "(new Uint8Array(${capacity}))"
  llvm """
    %buf = call %Pos @c_buffer_construct_uninitialized(i64 %capacity)
    ret %Pos %buf
  """

extern io def copy(b: Bytes): Bytes =
  js "bytes$copy$impl(${b})"
  llvm """
    %copy = call %Pos @c_buffer_copy(%Pos %b)
    ret %Pos %copy
  """

extern pure def size(b: Bytes): Int =
  js "${b}.length"
  llvm """
    %size = call i64 @c_buffer_length(%Pos %b)
    ret i64 %size
  """

extern io def get(b: Bytes, index: Int): Byte =
  llvm """
    %byte = call i8 @c_buffer_index(%Pos %b, i64 %index)
    ret i8 %byte
  """

extern io def write(b: Bytes, index: Int, value: Byte): Unit =
  llvm """
    call void @c_buffer_set(%Pos %b, i64 %index, i8 %value)
    ; return Unit
    ret %Pos zeroinitializer
  """

/**
 * Returns an *aliased* slice of b starting at offset with the given length
 */
extern io def slice(b: Bytes, offset: Int, length: Int): Bytes =
  js "new Uint8Array(${b}.buffer, ${offset}, ${length})"
  llvm """
    %buf = call %Pos @c_buffer_slice(%Pos %b, i64 %offset, i64 %length)
    ret %Pos %buf
  """

/**
 * Returns a view into the buffer, with the length truncated to n
 */
def truncated(b: Bytes, n: Int): Bytes =
  b.slice(0, n)

extern pure def toBytes(s: String): Bytes =
  js "(new TextEncoder().encode(${s}))"

extern pure def show(b: Bytes): String =
  js "(new TextDecoder('utf-8').decode(${b}))"
  // assuming the buffer is already in UTF-8
  llvm """
    %copy = call %Pos @c_buffer_copy(%Pos %b)
    ret %Pos %copy
  """


extern js """
  function bytes$copy$impl(original) {
    let copy = new Uint8Array(original.length);
    copy.set(original);
    return copy;
  }
"""
