module string

import effekt
import option
import list

// TODO
// - [ ] handle unicode codepoints (that can span two indices) correctly
// - [ ] use string buffers or other buffers to implement repeated concatenation more efficiently (and `join`)
// - [ ] maybe use native implementations for toInt, repeat, split, indexOf, etc.


extern pure def infixConcat(s1: String, s2: String): String =
  js "${s1} + ${s2}"
  chez "(string-append ${s1} ${s2})"
  ml "${s1} ^ ${s2}"

extern pure def length(str: String): Int =
  js "${str}.length"
  chez "(string-length ${str})"
  ml "String.size ${str}"

extern pure def unsafeSubstring(str: String, from: Int, to: Int): String =
  js "${str}.substring(${from}, ${to})"
  chez "(substring ${str} ${from} ${to})"
  ml "String.extract (${str}, ${from}, SOME (${to} - ${from}))"


def substring(str: String, from: Int, to: Int): String = {
  def clamp(lower: Int, x: Int, upper: Int) = max(lower, min(x, upper))

  str.unsafeSubstring(clamp(0, from, to), clamp(0, to, str.length))
}

def substring(str: String, from: Int): String =
  str.unsafeSubstring(from, str.length)


/**
 * Checks whether str starts with the given prefix at `from`
 */
def isSubstringAt(str: String, prefix: String, from: Int): Bool = {
  val stringLength = str.length
  val prefixLength = prefix.length

  def matched?(index: Int): Bool = index >= prefixLength
  def valid?(index: Int): Bool = (index + from) < stringLength
  def matches?(index: Int): Bool = prefix.charAt(index) == str.charAt(index + from)

  def go(index: Int): Bool =
    index.matched? || (index.valid? && index.matches? && go(index + 1))
  go(0)
}

def startsWith(str: String, prefix: String): Bool =
  isSubstringAt(str, prefix, 0)

def endsWith(str: String, suffix: String): Bool =
  isSubstringAt(str, suffix, str.length - suffix.length)

/**
 * Repeats the given string n-times.
 *
 * TODO use a more efficient way of appending strings like a buffer
 */
def repeat(str: String, n: Int): String = {
  def go(n: Int, result: String): String = {
    if (n == 0) result
    else go(n - 1, result ++ str)
  }
  go(n, "")
}

// TODO use .split() in JS
def split(str: String, sep: String): List[String] = {
  val strLength = str.length
  val sepLength = sep.length

  // special case: seperator is empty, just emit individual chars
  def empty(index: Int, components: List[String]): List[String] =
    if (index >= strLength) components.reverse
    else empty(index + 1, Cons(str.substring(index, index + 1), components))

  def go(lastIndex: Int, components: List[String]): List[String] =
    indexOf(str, sep, lastIndex) match {
      case None() =>
        Cons(str.substring(lastIndex, strLength), components).reverse
      case Some(index) =>
        go(index + sepLength, Cons(str.substring(lastIndex, index), components))
    }

  if (sepLength == 0) empty(0, Nil())
  else go(0, Nil())
}

def join(strings: List[String], sep: String): String = {
  def go(strings: List[String], result: String): String = strings match {
    case Nil() => result
    case Cons(s, rest) => go(rest, result ++ sep ++ s)
  }
  strings match {
    case Nil() => ""
    case Cons(first, rest) => go(rest, first)
  }
}

extern pure def trim(str: String): String =
  js "${str}.trim()"

// TODO optimize (right now this will be horribly slow (compared to the native JS version)
def toInt(str: String): Option[Int] = {

  val zero = '0'.toInt

  def go(index: Int, acc: Int): Option[Int] = str.charAt(index) match {
    case Some(c) and c >= '0' and c <= '9' =>
      go(index + 1, 10 * acc + (c.toInt - zero))
    case Some(c) => None()
    case None() => Some(acc)
  }
  str.charAt(0) match {
    case Some('-') => go(1, 0).map { n => 0 - n }
    case Some(_)   => go(0, 0)
    case None()    => None()
  }
}


// Native versions of toInt (unused right now)
//   ML: also accepts sml style `~2` for unary minus along with `+2` and `-2`
extern pure def unsafeToInt(str: String): Int =
  js "(Number.isNaN(parseInt(${str})) ? undefined : parseInt(${str}))"
  chez "(string->number ${str})"
  ml "Int.fromString ${str}"


/**
 * Returns the index of the first occurrence of `sub` in `str`
 */
def indexOf(str: String, sub: String): Option[Int] =
  indexOf(str, sub, 0)

def indexOf(str: String, sub: String, from: Int): Option[Int] = {
  val len = str.length
  def go(index: Int): Option[Int] =
    if (index >= len) None()
    else if (str.isSubstringAt(sub, index)) Some(index)
    else go(index + 1)

  go(from)
}

/**
 * Returns the index of the last occurence of `sub` in `str`
 */
def lastIndexOf(str: String, sub: String): Option[Int] =
  lastIndexOf(str, sub, str.length - 1)

def lastIndexOf(str: String, sub: String, from: Int): Option[Int] = {
  def go(index: Int): Option[Int] =
    if (index < 0) None()
    else if (str.isSubstringAt(sub, index)) Some(index)
    else go(index - 1)

  go(from)
}

// TODO more efficient (native) implementations could be integrated as follows

// extern pure def indexOf(str: String, sub: String): Option[Int] =
//   //js { nativeIndexOf(str, sub) }
//   default { indexOf(str, sub, 0) }

// def nativeIndexOf(str: String, sub: String): Option[Int] = {
//   val index = str.unsafeIndexOf(sub)
//   if (index < 0) { None() } else { Some(index) }
// }

// extern pure def unsafeIndexOf(str: String, sub: String): Int =
//   js "${str}.indexOf(${sub})"




// ANSI escape codes
namespace ANSI {
  val BLACK = "\u001b[30m"
  val RED = "\u001b[31m"
  val GREEN = "\u001b[32m"
  val YELLOW = "\u001b[33m"
  val BLUE = "\u001b[34m"
  val MAGENTA = "\u001b[35m"
  val CYAN = "\u001b[36m"
  val WHITE = "\u001b[37m"

  val BG_BLACK = "\u001b[40m"
  val BG_RED = "\u001b[41m"
  val BG_GREEN = "\u001b[42m"
  val BG_YELLOW = "\u001b[43m"
  val BG_BLUE = "\u001b[44m"
  val BG_MAGENTA = "\u001b[45m"
  val BG_CYAN = "\u001b[46m"
  val BG_WHITE = "\u001b[47m"

  val RESET = "\u001b[0m"
}


// Parsing
// -------
def toBool(s: String): Option[Bool] = s match {
  case "true"  => Some(true)
  case "false" => Some(false)
  case _ => None()
}

// Characters
// ----------
// JS: Int (Unicode codepoints)
// CS: Char

extern pure def toString(ch: Char): String =
  js "String.fromCodePoint(${ch})"
  chez "(string ${ch})"

extern pure def toInt(ch: Char): Int =
  js "${ch}"

extern pure def infixLt(x: Char, y: Char): Bool =
  js "(${x} < ${y})"

extern pure def infixLte(x: Char, y: Char): Bool =
  js "(${x} <= ${y})"

extern pure def infixGt(x: Char, y: Char): Bool =
  js "(${x} > ${y})"

extern pure def infixGte(x: Char, y: Char): Bool =
  js "(${x} >= ${y})"

def charAt(str: String, index: Int): Option[Char] =
  if (index < 0 ||  index >= length(str))
    None()
  else
    Some(unsafeCharAt(str, index))

extern pure def unsafeCharAt(str: String, n: Int): Char =
  js "${str}.codePointAt(${n})"
  chez "(string-ref ${str} ${n})"
  ml "SOME (String.sub (${str}, ${n}))" // Not unsafe in ML
